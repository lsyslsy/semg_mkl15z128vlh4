/* ###################################################################
 **     THIS COMPONENT MODULE IS GENERATED BY USER.
 **     Filename    : Macros.h
 **     Project     : semg_mkl15z128vlh4
 **     Processor   : MKL15Z128VLH4
 **     Component   :
 **     Version     :
 **     Compiler    : GNU C Compiler
 **     Date/Time   : 2013-07-12, 12:30, # CodeGen: 0
 **     Author	    : Dong
 **     Abstract    :
 **          This file contains user macros used in this project.
 **
 **
 **     Mail      	: pzdongdong@163.com
 **
 **     Revision    : No.  Name        Date/Time        Content
 ** ###################################################################*/
/*!
 * @file Macros.h
 * @version 01.00
 * @brief
 *      This file contains user macros used in this project.
 *
 */
/*!
 *  @addtogroup UserMacros User Macros
 *      This module contains user macros used in this project.
 *  @{
 */

#ifndef MACROS_H_
#define MACROS_H_
/* MODULE USER MACROS */

#include "Settings.h"
#include "PE_Types.h"


/*
 * ===================================================================
 * User Macros Definition
 * ===================================================================
 */

    /*
     * ===================================================================
     * System Constants
     * ===================================================================
     */
    /*!
     * @addtogroup SysConst System Constants
     * @{
     */
#if USING_MKL15Z128VLH4
#define USING_ADC_COUNT 2U                                     /*!< The count of ADC used. */
extern const uint32 MIN_SYSTICK_VALUE;                         /*!< Minimum value of the SysTick value register. */
extern const uint32 MAX_SYSTICK_VALUE;                         /*!< Maximum value of the SysTick value register. */
extern const uint32 TICK_TO_US_PROCESSOR_CLOCK;                /*!< 48 ticks equals to 1us, when using processor clock(48MHz). */
extern const uint32 TICK_TO_US_EXTERNAL_CLOCK;                 /*!< 3 ticks equals to 1us, when using external clock(3MHz). */
extern const uint32 TICK_TO_MS_PROCESSOR_CLOCK;                /*!< 4800 ticks equals to 1ms, when using processor clock(48MHz). */
extern const uint32 TICK_TO_MS_EXTERNAL_CLOCK;                 /*!< 3000 ticks equals to 1ms, when using external clock(3MHz). */
extern const uint32 MIN_DELAY_US;                              /*!< Minimum microseconds to delay when using SysTick. */
extern const uint32 MIN_DELAY_TIME;                            /*!< Minimum delay time is 1us/ms/s. */
    #if PROCESSOR_CLOCK_48MHZ
extern const uint32 PROCESSOR_CLOCK;                           /*!< Processor clock frequency is 48MHz. */
extern const uint32 MAX_DELAY_US_PROCESSOR_CLOCK;              /*!< Maximum delay microseconds of a 48MHz is 349525us. */
extern const uint32 MAX_DELAY_MS_PROCESSOR_CLOCK;              /*!< Maximum delay milliseconds of a 48MHz is 349ms. */
extern const uint32 MAX_DELAY_MS_EXTERNAL_CLOCK;               /*!< Maximum delay milliseconds of a 3MHz is 5592ms. */
    #endif  /* #if PROCESSOR_CLOCK_48MHZ */
extern const uint32 SYSTICK_USE_PROCESSOR_CLOCK;               /*!< SysTick uses processor clock. */
extern const uint32 SYSTICK_USE_EXTERNAL_CLOCK;                /*!< SysTick uses external clock. */
extern const uint8 MCU_NUMBER;                                 /*!< The number of MCU. */
#endif  /* #if USING_MKL15Z128VLH4 */
    /*!
     * @}
     */
    /*!
     * @addtogroup ADCConst ADC Constants
     * @{
     */
#if USING_ADS1198
#define REGISTER_COUNT 26U                                     /*!< Count of registers in ADS1198. */
#define CHANNEL_COUNT 0x08U                                    /*!< Count of ADC's channel. */
#define RAW_DATA_HEAD_SIZE 3U                                  /*!< Head size of raw data from ADC. */
#define USING_CHANNEL_COUNT 0x08U                              /*!< Count of ADC channels used currently. */
#define RAW_DATA_SIZE 19U                                      /*!< Size of raw data: 19Bytes = 3Bytes + USING_CHANNEL_COUNT * 2Bytes. */

extern const uint8 MIN_CHANNEL_NUMBER;                         /*!< Minimum number of ADC channels. */
extern const uint8 MAX_CHANNEL_NUMBER;                         /*!< Maximum number of ADC channels. */
extern const uint8 MIN_REGISTER_READ_NUMBER;                   /*!< Minimum number of registers to be read. */
extern const uint8 MAX_REGISTER_READ_NUMBER;                   /*!< Maximum number of registers to be read. */
extern const byte RAW_DATA_HEAD;                               /*!< The first 4 bits of right ADC value must be 0b1100. */
extern const uint8 RAW_DATA_HEAD_MASK;                         /*!< The mask of first 4 bits. The right value is always 0b1100. */
extern const uint8 RAW_DATA_GPIO_MASK;                         /*!< The mask of GPIO data of ADC value. */
extern const uint8 BYTE_COUNT_PER_CHANNEL;                     /*!< The count of bytes per channel's data. */
#endif  /* #if USING_ADS1198 */
    /*!
     * @}
     */
    /*!
     * @addtogroup DMAConst DMA constants
     * @{
     */
#if USING_DMA
extern const uint8 SPI1_TX_DMA_CHANNEL;
extern const uint8 SPI1_RX_DMA_CHANNEL;
extern const uint8 SPI0_TX_DMA_CHANNEL;
extern const uint8 SPI0_RX_DMA_CHANNEL;
#endif /* #if USING_DMA */
    /*!
     * @}
     */
    /*!
     * @addtogroup ARMConst ARM constants
     * @{
     */
#define CHANNEL_DATA_COUNT 100U                                /*!< The count of channel data uploaded to ARM each time per ADC. */
/*!
 * The length of channel package.
 *
   @verbatim
   ----------------------------------------------------------------------------------------
   |0x11|channel_num|channel_state|(channel_data_high+channel_data_low)*CHANNEL_DATA_COUNT|
   ----------------------------------------------------------------------------------------
   @endverbatim
 */
#define CHANNEL_PACKAGE_LENGTH 203U                            /*!< The length of a channel package. */
extern const byte CHANNEL_PACKAGE_HEAD_BIT;                    /*!< The head bit of channel data package. */

/*!
 * The length of data frame.
 *
   @verbatim
   ---------------------------------------------------------------------------------------------------------------------------------
   |0xb7|MCU_NUMBER|channel_package_length_high|channel_package_length_low|channel_package*USING_CHANNEL_COUNT*USING_ADC_COUNT|0xed|
   ---------------------------------------------------------------------------------------------------------------------------------
   @endverbatim
 */
#if USING_ADC_COUNT == 1U
#define DATA_FRAME_LENGTH 1629                                 /*!< The length of a data frame when using 1 ADC. */
#elif USING_ADC_COUNT == 2U
#define DATA_FRAME_LENGTH 3253                                 /*!< The length of a data frame when using 2 ADC. */
#endif /* #if USING_ADC_COUNT == 1U */
extern const byte DATA_FRAME_HEAD_BIT;                         /*!< The head bit of data frame. */
extern const byte DATA_FRAME_TAIL_BIT;                         /*!< The tail bit of data frame. */
    /*!
     * @}
     */

    /*
     * ===================================================================
     * ADC Commands and Registers Map
     * ===================================================================
     */
    /*!
     * @addtogroup ADCCmdReg ADC Commands and Registers Map
     * @{
     */
        /*!
         * @addtogroup ADCCmd ADC Commands
         * @{
         */
#if USING_ADS1198

extern const uint8 ADC_CMD_WAKEUP;
extern const uint8 ADC_CMD_STANDBY;
extern const uint8 ADC_CMD_RESET;
extern const uint8 ADC_CMD_START;
extern const uint8 ADC_CMD_STOP;
extern const uint8 ADC_CMD_RDATAC;                             /*!< ADC runs in Read Data Continuous mode. */
extern const uint8 ADC_CMD_SDATAC;                             /*!< Cancel RDATAC mode. */
extern const uint8 ADC_CMD_RDATA;                              /*!< If in SDATAC mode, read data from ADC when ~DRDY goes low. */
#define ADC_CMD_RREG(reg_addr)    0x20U + reg_addr             /*!< reg_addr - The starting address the registers to be read. */
#define ADC_CMD_WREG(reg_addr)    0x40U + reg_addr             /*!< reg_addr - The starting address the registers to be write. */
        /*!
         * @}
         */
        /*!
         * @addtogroup ADCReg ADC Registers
         * @{
         */
            /*!
             * @addtogroup DevSet Device Settings
             * @{
             */
extern const uint8 ADC_REG_ID;                                 /*!< Read-only register. */
            /*!
             * @}
             */
            /*!
             * @addtogroup GblSet Global Settings Across Channels
             * @{
             */
extern const uint8 ADC_REG_CONFIG1;
extern const uint8 ADC_REG_CONFIG2;
extern const uint8 ADC_REG_CONFIG3;
extern const uint8 ADC_REG_LOFF;
            /*!
             * @}
             */
            /*!
             * @addtogroup  ChnSet Channel-Specific Settings
             * @{
             */
extern const uint8 ADC_REG_CH1SET;
extern const uint8 ADC_REG_CH2SET;
extern const uint8 ADC_REG_CH3SET;
extern const uint8 ADC_REG_CH4SET;
extern const uint8 ADC_REG_CH5SET;                             /*!< Not available for the ADS1194. */
extern const uint8 ADC_REG_CH6SET;                             /*!< Not available for the ADS1194. */
extern const uint8 ADC_REG_CH7SET;                             /*!< Not available for the ADS1194 and ADS1196. */
extern const uint8 ADC_REG_CH8SET;                             /*!< Not available for the ADS1194 and ADS1196. */
extern const uint8 ADC_REG_RLD_SENSP;                          /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
extern const uint8 ADC_REG_RLD_SENSN;                          /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
extern const uint8 ADC_REG_LOFF_SENSP;                         /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
extern const uint8 ADC_REG_LOFF_SENSN;                         /*!< Bits[7:4] are not available for the ADS1194. Bits[7:6] are not available for the ADS1196. */
extern const uint8 ADC_REG_LOFF_FLIP;
            /*!
             * @}
             */
            /*!
             * @addtogroup  LOFFStatReg Lead-Off Status Registers
             * @{
             */
extern const uint8 ADC_REG_LOFF_STATP;                         /*!< Read-only register. */
extern const uint8 ADC_REG_LOFF_STATN;                         /*!< Read-only register. */
            /*!
             * @}
             */
            /*!
             * @addtogroup  GPIO_Oth GPIO and OTHER Registers
             *      Address 16h is reserved.
             * @{
             */
extern const uint8 ADC_REG_GPIO;
extern const uint8 ADC_REG_PACE;
/* extern const uint8 ADC_REG_RESERVED; */                     /* Reserved. */
extern const uint8 ADC_REG_CONFIG4;
extern const uint8 ADC_REG_WCT1;
extern const uint8 ADC_REG_WCT2;

#endif /* #if USING_ADS1198 */
            /*!
             * @}
             */
        /*!
         * @}
         */
    /*!
     * @}
     */

/*
 * ===================================================================
 * User Type Definition
 * ===================================================================
 */
    /*!
     * @addtogroup StrcGrp Structure Group
     * @{
     */
        /*!
         * @addtogroup AdcStrc ADC Structure
         * @{
         */
/*!
 * A structure of channel data from ADC.
 *
   @verbatim
   ---------------------------------------------------------------------------------------------------------
   |  Head   |   LOFF_STATP    |   LOFF_STATN    |GPIO[4:7]|                  CH[1-8] Data                 |
   ---------------------------------------------------------------------------------------------------------
   | 1 1 0 0 | x x x x x x x x | x x x x x x x x | x x x x | CH1 | CH2 | CH3 | CH4 | CH5 | CH6 | CH7 | CH8 |
   ---------------------------------------------------------------------------------------------------------
   |                        3Bytes                         |                  8*2=16Bytes                  |
   ---------------------------------------------------------------------------------------------------------

   -----------------------------------------------------------------
   | M |                       CHn Data                        | L |
   -----------------------------------------------------------------
   |1 5|1 4|1 3|1 2|1 1|1 0| 9 | 8 | 7 | 6 | 5 | 4 | 3 | 2 | 1 | 0 |
   -----------------------------------------------------------------
   | x | x | x | x | x | x | x | x | x | x | x | x | x | x | x | x |
   -----------------------------------------------------------------
   |             1Byte             |             1Byte             |
   -----------------------------------------------------------------
   @endverbatim
 */
struct TADCData
{
    byte  head;                                                /*!< The head bits of data should always be 0b00001100. */
    byte  loffStatP;                                           /*!< The value of the register LOFF_STATP. */
    byte  loffStatN;                                           /*!< The value of the register LOFF_STATN. */
    byte  regGPIOData;                                         /*!< The value of bit[4-7] of the register GPIO. */
    byte  rawData[RAW_DATA_SIZE];                              /*!< The raw data from ADC, including status bytes. */
    int16 channelData[USING_CHANNEL_COUNT];                    /*!< The value of every channel's data, transformed from raw data. */
};
typedef struct TADCData TADCData;
typedef struct TADCData* TADCDataPtr;

/*!
 * A structure of ADC's setting.
 */
struct TADCSetting
{
    volatile bool isChannelEnabled[CHANNEL_COUNT];             /*!< Flag of whether channel is enabled. */
};
typedef struct TADCSetting TADCSetting;
typedef struct TADCSetting* TADCSettingPtr;

/*!
 * A structure of ADC's status.
 */
struct TADCStatus
{
    volatile bool isDataReady;                                 /*!< Flag of whether ADC' data is ready. */
};
typedef struct TADCStatus TADCStatus;
typedef struct TADCStatus* TADCStatusPtr;

/*!
 * A structure of ADC device.
 */
struct TADC
{
    TADCStatus adcStatus;
    TADCSetting adcSetting;
    TADCData adcData;
};
typedef struct TADC TADC;
typedef struct TADC* TADCPtr;
        /*!
         * @}
         */

        /*!
         * @addtogroup McuStrc MCU Structure
         * @{
         */
/*!
 * A structure of data being processing or processed in MCU.
 */
struct TMCUData
{
    int16 channelData[USING_CHANNEL_COUNT][CHANNEL_DATA_COUNT];            /*!< The value of every channel's data from ADC. */
    int16 filteredChannelData[USING_CHANNEL_COUNT][CHANNEL_DATA_COUNT];    /*!< The value of every channel's data that has been filtered. */
};
typedef struct TMCUData TMCUData;
typedef struct TMCUData* TMCUDataPtr;

/*!
 * A structure of MCU's setting.
 */
struct TMCUSetting
{

};
typedef struct TMCUSetting TMCUSetting;
typedef struct TMCUSetting* TMCUSettingPtr;

/*!
 * A structure of MCU's Status.
 */
struct TMCUStatus
{
    volatile bool isReceivingADCData;                          /*!< Flag of whether MCU is receiving data from ADC. */
    volatile bool isMasterReceived;                            /*!< Flag of whether Master SPI finishing reception. */
    volatile bool isMasterSent;                                /*!< Flag of whether Master SPI finishing transmission. */
    volatile bool isSlaveReceived;                             /*!< Flag of whether Slave SPI finishing reception. */
    volatile bool isSlaveSent;                                 /*!< Flag of whether Slave SPI finishing transmission. */
    volatile bool isUartReceived;                              /*!< Flag of whether UART finishing reception. */
    volatile bool isUartSent;                                  /*!< Flag of whether UART finishing transmission. */
    volatile bool isUploadReady;                               /*!< Flag of whether data is ready for uploading to ARM. */
    volatile bool isSPI0TxDMATransCompleted;                   /*!< Flag of whether SPI0 DMA transmission is completed. */
    volatile bool isSPI0RxDMATransCompleted;                   /*!< Flag of whether SPI0 DMA reception is completed. */
    volatile bool isSPI1TxDMATransCompleted;                   /*!< Flag of whether SPI1 DMA transmission is completed. */
    volatile bool isSPI1RxDMATransCompleted;                   /*!< Flag of whether SPI1 DMA reception is completed. */
    volatile bool isDelayed;                                   /*!< Flag of whether delayed. */
};
typedef struct TMCUStatus TMCUStatus;
typedef struct TMCUStatus* TMCUStatusPtr;

/*!
 *  A structure of MCU device.
 */
struct TMCU
{
    TMCUStatus mcuStatus;
    TMCUSetting mcuSetting;
    TMCUData mcuData;
};
typedef struct TMCU TMCU;
typedef struct TMCU* TMCUPtr;
        /*!
         * @}
         */

        /*!
         * @addtogroup ArmStrc ARM Structure
         * @{
         */
/*!
 * A structure of data from or to ARM.
 */
struct TARMData
{
    int8 dataHigh[USING_CHANNEL_COUNT];                        /*!< The high byte of filtered channel data being transmitting to ARM. */
    int8 dataLow[USING_CHANNEL_COUNT];                         /*!< The low byte of filtered channel data being transmitting to ARM. */
    byte dataFrame[DATA_FRAME_LENGTH];                         /*!< The data frame transmitted to ARM. */
};
typedef struct TARMData TARMData;
typedef struct TARMData* TARMDataPtr;

/*!
 * A structure of ARM's setting.
 */
struct TARMSetting
{

};
typedef struct TARMSetting TARMSetting;
typedef struct TARMSetting* TARMSettingPtr;

/*!
 * A structure of ARM's status.
 */
struct TARMStatus
{
    volatile bool isRequiringData;                             /*!< Flag of whether arm requires data. */
};
typedef struct TARMStatus TARMStatus;
typedef struct TARMStatus* TARMStatusPtr;

/*!
 *  A structure of ARM device.
 */
struct TARM
{
    TARMStatus armStatus;
    TARMSetting armSetting;
    TARMData armDataLeft;
    TARMData armDataRight;
};
typedef struct TARM TARM;
typedef struct TARM* TARMPtr;
        /*!
         * @}
         */
    /*!
     * @}
     */
/*
 * ===================================================================
 * Error Message
 * ===================================================================
 */

    /*!
     * @addtogroup ErrMsg Error Message
     * @{
     */
#if DEBUG
extern const char* const ERR_MSG_OK;
extern const char* const ERR_MSG_SPEED;
extern const char* const ERR_MSG_RANGE;
extern const char* const ERR_MSG_VALUE;
extern const char* const ERR_MSG_OVERFLOW;
extern const char* const ERR_MSG_MATH;
extern const char* const ERR_MSG_ENABLED;
extern const char* const ERR_MSG_DISABLED;
extern const char* const ERR_MSG_BUSY;
extern const char* const ERR_MSG_NOTAVAIL;
extern const char* const ERR_MSG_RXEMPTY;
extern const char* const ERR_MSG_TXFULL;
extern const char* const ERR_MSG_BUSOFF;
extern const char* const ERR_MSG_OVERRUN;
extern const char* const ERR_MSG_FRAMING;
extern const char* const ERR_MSG_PARITY;
extern const char* const ERR_MSG_NOISE;
extern const char* const ERR_MSG_IDLE;
extern const char* const ERR_MSG_FAULT;
extern const char* const ERR_MSG_BREAK;
extern const char* const ERR_MSG_CRC;
extern const char* const ERR_MSG_ARBITR;
extern const char* const ERR_MSG_PROTECT;
extern const char* const ERR_MSG_UNDERFLOW;
extern const char* const ERR_MSG_UNDERRUN;
extern const char* const ERR_MSG_COMMON;
extern const char* const ERR_MSG_LINSYNC;
extern const char* const ERR_MSG_FAILED;
extern const char* const ERR_MSG_QFULL;
extern const char* const ERR_MSG_WRITE_FAILED;
extern const char* const ERR_MSG_PARAM_MASK;
extern const char* const ERR_MSG_PARAM_MODE;
extern const char* const ERR_MSG_PARAM_INDEX;
extern const char* const ERR_MSG_PARAM_DATA;
extern const char* const ERR_MSG_PARAM_SIZE;
extern const char* const ERR_MSG_PARAM_VALUE;
extern const char* const ERR_MSG_PARAM_RANGE;
extern const char* const ERR_MSG_PARAM_LOW_VALUE;
extern const char* const ERR_MSG_PARAM_HIGH_VALUE;
extern const char* const ERR_MSG_PARAM_ADDRESS;
extern const char* const ERR_MSG_PARAM_PARITY;
extern const char* const ERR_MSG_PARAM_WIDTH;
extern const char* const ERR_MSG_PARAM_LENGTH;
extern const char* const ERR_MSG_PARAM_ADDRESS_TYPE;
extern const char* const ERR_MSG_PARAM_COMMAND_TYPE;
extern const char* const ERR_MSG_PARAM_COMMAND;
extern const char* const ERR_MSG_PARAM_RECIPIENT;
extern const char* const ERR_MSG_PARAM_BUFFER_COUNT;
extern const char* const ERR_MSG_PARAM_ID;
extern const char* const ERR_MSG_PARAM_GROUP;
extern const char* const ERR_MSG_PARAM_CHIP_SELECT;
extern const char* const ERR_MSG_PARAM_ATTRIBUTE_SET;
extern const char* const ERR_MSG_PARAM_SAMPLE_COUNT;
extern const char* const ERR_MSG_PARAM_CONDITION;
extern const char* const ERR_MSG_PARAM_TICKS;
extern const char* const ERR_MSG_UNKNOWN;
#endif  /* #if DEBUG */
    /*!
     * @}
     */

    /* END Macros. */

#endif
/* #ifndef MACROS_H_ */

/*!
 * @}
 */
/*
 ** ###################################################################
 **
 **     This file was created by Dong
 **     for the Freescale Kinetis series of microcontrollers.
 **
 ** ###################################################################
 */
